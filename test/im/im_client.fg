#import '../ui'
import '../mesh'
import 'im'


####### net

#id = 'client' + id
id = 'client' + test_init()
pw = id


client = [

    'contacts' : (sys.load('contacts') or []),
    'roster' : [],
    'unread' : [],
    'mesh' : Mesh,
    'port' : port,

    'handle_message' : function(self, socket, mc1)
        e = mc1.event
        if (e == 'greet') then
            sys.print(self.mesh.id + ' greet ' + self.entrance + ' ' + self.creds)
            return ['event' : self.entrance] + self.creds
        else if e == 'signined' then
            self.handle_signined(socket, mc1)
        else if e == 'chat' then
            self.handle_chat(mc1.chat, mc1.from)
        else if e == 'contacts' then
            self.handle_contacts(mc1.contacts)
        else if e == 'online' then
            self.handle_online(mc1.from, mc1.online)
        else if e == 'test' then
            self.handle_test(mc1)
            return
        else
            self.sync.handle_message(socket, mc1)
        end
    end,

    'connect' : function(self, id)
        self.mesh = self.mesh.init(id or self.creds.id, self.port, [self])
#        if self.server # already connected
#            self.mesh.send_greet(nil, 'server')
#        else
            self.mesh.connect()
#        end
    end,

    'connected' : function(self, socket)
        self.mesh.print('connected ' + socket)
        self.server = socket
        for m in self.mq
            self.mesh.send(self.server, m)
        end
    end,

    'handle_contacts' : function(self, contacts)
        self.mesh.print('handle_contacts ' + contacts)
        self.contacts = contacts
        onlines = self.available_contacts()
        self.update_roster(onlines)
    end,

    'handle_online' : function(self, from, state)
        self.contacts[from].online = state
        self.mesh.print('handle_online ' + self.contacts)
        onlines = self.available_contacts()
        self.update_roster(onlines)
    end,

    'available_contacts' : function(self)
        sys.print('ac : ' + self.contacts)
        self.roster = [k for k,v in self.contacts where v.online]
        sys.print('roster : ' + self.roster)
        return self.roster
    end,

    'update_roster' : function(self, contacts)
        sys.ui_set(self.ui.roster)
    end,

    'handle_signined' : function(self, socket, mc3)
        if mc3.token then
            self.token = mc3.token
            self.contacts = mc3.contacts
            sys.save(self.creds, 'creds')
            self.main()
        else
            self.creds = nil
            sys.ui_set(self.ui.error, mc3.error)
        end
    end,


####### ui

    'select' : function(self)

        self.transcript = ''
        row = sys.args()[1]
        peer = self.roster[row]
        send = function(self)(peer)
            text = sys.form_get(self.ui).sezme
            msgtext = ['from':self.mesh.id, 'to':peer, 'event':'chat', 'chat':text]
            self.update_transcript('you', text)
            self.mesh.send(self.server, msgtext)
        end

        self.ui = sys.ui(self,
                        ['horizontal',

                            ['table', 'name':'roster', 'list':self.available_contacts(), 'logic':self.select, 'hfill':true, 'width':0.25],
                            ['vertical',
                                ['input', 'name':'transcript', 'multiline':true, 'readonly':true, 'hfill':true],
                                ['input', 'name':'sezme'],
                                ['button', 'text':'send', 'logic':send],
                            ]
                        ])
        self.peer = peer

    end,

    'update_transcript' : function(self, from, text)
        if self.transcript.length then
            self.transcript = self.transcript + '\n'
        end
        self.transcript = self.transcript + from +':'+ text
        sys.ui_set(self.ui.transcript, self.transcript)
    end,

    'handle_chat' : function(self, chat, from)

        if from == self.peer then
            self.update_transcript(from, chat)
        else
            self.unread[from] = self.unread + [chat]
            roster = [r+ '(' + self.unread[r].length + ')' for r in self.contacts where r.online]
            sys.ui_set(self.ui.roster, roster)
        end

    end,

    'send' : function(self, other, text)

        text = text or sys.form_get(self.ui).sezme
        msgtext = ['event':'text', 'text':text]
        other = other or peer
        self.mesh.send_to(other, msgtext)

    end,

    'showContacts' : function(self)

        self.ui = sys.ui(self, ['vertical',
                            ['table', 'name':'contacts', 'list':self.contacts.keys, 'logic':self.selectContact],
                            ['button', 'text':'back to settings', 'logic':self.settings],
                            self.w, self.h
                        ])
    end,

    'selectContact' : function(self)

        row = sys.args()[1]
        self.peer = self.contacts.keys[row]

        sys.print('sp='+self.peer)

        self.ui = sys.ui(self, ['vertical',
                            ['label', 'text':self.peer],
                            ['form', 'name'],
                            ['button', 'text':'delete', 'logic':self.deleteContact],
                            self.w, self.h
                        ])

        sys.form_set(['name':self.peer])

    end,

    'deleteContact' : function(self)

        self.contacts = self.contacts - self.peer
        mc4 = ['event' : 'contacts', 'contacts' : self.contacts]
        self.mesh.send_to('server', mc4)
        self.settings()

    end,

    'settings' : function(client)

        client.ui = sys.ui(client, ['vertical',

                            ['form', 'server', 'display name', 'id', 'pw'],

                            ['button', 'text':'contacts', 'logic':client.showContacts],

                            ['horizontal',
                                ['button', 'text':'save',   'logic':sys.save(sys.form_get(client.ui), 'settings')],
                                ['button', 'text':'cancel', 'logic':client.main],
                                ['button', 'text':'logout', 'logic':client.main],
                            ],

                            client.w, client.h
                        ])

        f = sys.load('settings')
        sys.form_set(f)
    end,

    'main' : function(self)

        self.ui = sys.ui(self, ['vertical',

                                    ['horizontal',
                                        ['button', 'text':'add',      'logic':self.add],
                                        ['button', 'text':'settings', 'logic':self.settings],
                                    ],

                                    ['table', 'name':'roster', 'list':self.available_contacts(), 'logic':self.select],

                                    self.w, self.h
                                ])

    end,

    'add' : function(self)

        self.ui = sys.ui(self,

                        ['vertical',

                            ['form', 'id'],

                            ['horizontal',
                                ['button', 'text':'add',       'logic':self.added],
                                ['button', 'text':'nevermind', 'logic':self.main],
                            ],

                            self.w, self.h
                        ])
    end,

    'added' : function(self)
        friend = sys.form_get(self.ui).id
        self.add_contact(friend)
        self.main()
    end,

    'add_contact' : function(self, friend)
        self.contacts[friend] = []
        sys.print('fz ' + friend + ' -- ' + self.contacts)
        mc4 = ['event' : 'contacts', 'contacts' : self.contacts.keys]
        self.mesh.send_to('server', mc4)
    end,

    'signin' : function(self, id, pw, entrance)
        sys.print(self.mesh.id + ' signin1 ' + entrance + ' ' + id + ' ' + pw)
        self.mq = [['event':entrance or 'signin', 'id':id, 'pw':pw]]
        self.connect()
    end,

    'signout' : function(self)
        msgso = ['event':'signout', self.token]
        self.mesh.send_to('server', msgso)
    end,

    'forget' : function(self)
        msgf = ['event':'forget', self.token]
        self.mesh.send_to('server', msgf)
    end,

    'signup' : function(self, id, pw)
        self.signin(id, pw, 'signup')
    end,

    'ui_login' : function(self)
        self.ui = sys.ui(self, ['vertical',
                                     ['form', 'server', 'id', 'pw'],
                                     ['horizontal',
                                         ['button', 'text':'signin', 'logic':self.signin],
                                         ['button', 'text':'signup', 'logic':self.signup],
                                     ],
                                     self.w, self.h
                                ])
    end,

    'login' : function(self)

        # todo -- make autologin work
        #if self.creds = sys.load('creds') then
        #    self.signin()
        #else
            self.ui_login()
            sys.loop()
        #end
    end,

    ####### test

    'handle_test' : function(self, msg7)

        action = msg7.action
        path = self.watched + msg7.path
        status = 'done'

        # if not msg7.retry then self.mesh.print('test ' + msg7.seq  +': '+ msg7) end

        if action == 'signup' then
            self.signup(msg7.id, msg7.pw)

        else if action == 'signin' then
            self.signin(msg7.id, msg7.pw)

        else if action == 'signout' then
            self.signout()

        else if action == 'forget' then
            self.forget()

        else if action == 'presence' then
            if msg7.online == nil then
                self.add_contact(msg7.id)
            else
                status = self.roster[msg7.who] == msg7.online
        end

        else if action == 'offline' then
            self.offline = true
        else if action == 'online' then
            self.offline = nil
            self.mesh.connected()

        else if action == 'die' then
            sys.sleep(1000) # wait for broadcast to go out
            self.mesh.print('exiting')
            sys.exit(0)

        else
            status = 'fail: unknown action ' + action
        end

        #self.mesh.print('result for ' + action +': '+ status)

        msg8 = ['event' : 'test', 'status' : status, 'seq' : msg7.seq, 'to' : msg7.from]
        self.mesh.send_to('server', msg8)

    end
]



if id then
    client.connect(id)
else
    client.login()
end

sys.loop()
